
/**
 * Core Philosophy: This ruleset establishes a security model for a church application,
 * balancing public access to information with secure, context-aware write permissions.
 * Most top-level collections like events and sermons are publicly readable to signed-in
 * users, with writes reserved for future administrative roles. User-generated content
 * like prayer requests follows a "drop-box" model (write-only), ensuring privacy.
 *
 * Data Structure: The data is organized into a flat structure with five main
 * top-level collections: /events, /sermons, /testimonies, /prayer_requests, and /donations.
 * This segregation simplifies security rules by avoiding complex hierarchical lookups
 * and ensures performant queries.
 *
 * Key Security Decisions:
 * - Default Read Access: Most data is readable by any authenticated user. Anonymous
 *   users have no access.
 * - Admin-Only Writes: Collections like /events and /sermons are intended to be
 *   managed by administrators. As no admin role system is defined in the current
 *   schema, all write operations on these collections are disabled by default as a
 *   security measure.
 * - Testimony Ownership: The rules anticipate that testimonies should be editable only
 *   by their original authors. The data model now includes a secure 'authorId' (UID) field.
 * - Private Prayer Requests: The /prayer_requests collection is configured as a
 *   "write-only" drop box. Any signed-in user can submit a new request, but no user
 *   (including the author) can read, update, or delete requests through the client,
 *   ensuring privacy.
 * - Private Donations: The /donations collection is written by a trusted backend
 *   service. Client-side, users are only permitted to read their own donation history.
 * - Backend Validation: All user-created data (User Profiles, Testimonies, Prayer Requests)
 *   is validated against a strict schema to ensure data integrity and prevent malformed data.
 *
 * Denormalization for Authorization: This ruleset is designed with denormalization in
 * mind. For user-owned content (like Testimonies and User Profiles), it is critical that an `authorId` or `uid`
 * field containing the user's UID is stored directly on the document. This avoids
 * slow and costly `get()` calls and is the only secure way to enforce ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // --- User Profile Validation Functions ---
    function isCreatingUserProfile(data) {
      // Core fields that are always required
      let requiredFields = ['uid', 'name', 'email', 'createdAt'];
      let baseValidation = data.uid == request.auth.uid
        && data.name is string && data.name.size() >= 2
        && data.email is string
        && data.email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}$');

      // Handle optional 'whatsappNumber' field
      if (data.keys().hasAny(['whatsappNumber'])) {
        return baseValidation
          && data.whatsappNumber is string
          && data.keys().hasAll(requiredFields.concat(['whatsappNumber']))
          && data.keys().size() == 5;
      } else {
        return baseValidation
          && data.keys().hasAll(requiredFields)
          && data.keys().size() == 4;
      }
    }
    
    function canUpdateUserProfile(incoming, existing) {
      // User can only update their name and whatsappNumber
      let canUpdate = incoming.name is string && incoming.name.size() >= 2;

      // Allow whatsappNumber to be updated or removed
      if (incoming.keys().has('whatsappNumber')) {
          canUpdate = canUpdate && incoming.whatsappNumber is string;
      }

      // Ensure immutable fields are not changed
      let immutableFieldsUnchanged = incoming.uid == existing.uid
          && incoming.email == existing.email
          && incoming.createdAt == existing.createdAt;

      // Ensure no extra fields are added and only allowed fields are present
      let allowedKeys = ['uid', 'name', 'email', 'createdAt', 'whatsappNumber'];
      let keysAreValid = incoming.keys().hasOnly(allowedKeys);

      return canUpdate && immutableFieldsUnchanged && keysAreValid;
    }
    
    // --- Testimony Validation Functions ---
    function isCreatingTestimony(data) {
      return data.keys().hasAll(['author', 'authorId', 'content', 'date', 'approved'])
        && data.author is string && data.author.size() > 0
        && data.authorId == request.auth.uid
        && data.content is string && data.content.size() >= 20 && data.content.size() <= 1000
        && data.date == request.time
        && data.approved == false; // Users can only create unapproved testimonies
    }
    
    // --- Prayer Request Validation Functions ---
    function isCreatingPrayerRequest(data) {
        return data.keys().hasAll(['author', 'content', 'date', 'isAnonymous'])
            && data.author is string
            && data.content is string && data.content.size() > 0
            && data.date == request.time
            && data.isAnonymous is bool;
    }

    /**
     * @description User profile data. A user can manage their own profile.
     * @path /users/{userId}
     * @allow A user can read, create, update, and delete their own profile.
     * @allow Create and update operations are validated against a schema.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow create: if isOwner(userId) && isCreatingUserProfile(request.resource.data);
      allow update: if isOwner(userId) && canUpdateUserProfile(request.resource.data, resource.data);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Publicly readable church events.
     * @path /events/{eventId}
     * @allow A signed-in user (auth!=null) can read a specific event. (get)
     * @deny An anonymous user (auth==null) tries to read an event. (get)
     * @principle Enforces public read access for authenticated users, while securing all write operations for future admin roles.
     */
    match /events/{eventId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create, update, delete: if false; // Writes are disabled until an admin/personnel role system is implemented.
    }

    /**
     * @description Publicly readable sermon records.
     * @path /sermons/{sermonId}
     * @allow A signed-in user (auth!=null) can list all sermons. (list)
     * @deny Any user, signed-in or not, tries to create a new sermon. (create)
     * @principle Enforces public read access for authenticated users, while securing all write operations for future admin roles.
     */
    match /sermons/{sermonId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create, update, delete: if false; // Writes are disabled until an admin/personnel role system is implemented.
    }

    /**
     * @description User-submitted testimonies.
     * @path /testimonies/{testimonyId}
     * @allow Authenticated users can read testimonies.
     * @allow A user can create their own testimony (with validation).
     * @allow A user can delete their own testimony.
     * @deny Users cannot update testimonies for now.
     * @principle Public read for authenticated users, with owner-only writes.
     */
    match /testimonies/{testimonyId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && isCreatingTestimony(request.resource.data);
      allow update: if false; // Disallowed until a proper update flow is designed.
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description A private "drop-box" for user-submitted prayer requests.
     * @path /prayer_requests/{prayerRequestId}
     * @allow A signed-in user (auth!=null) submits a new, validated prayer request. (create)
     * @deny Any user, including the original author, attempts to read, update, or delete a prayer request. (get, update, delete)
     * @principle Implements a "write-only" pattern. Data can be submitted by any authenticated user but cannot be read back, ensuring privacy.
     */
    match /prayer_requests/{prayerRequestId} {
      allow create: if isSignedIn() && isCreatingPrayerRequest(request.resource.data);
      allow get, list, update, delete: if false;
    }

    /**
     * @description Stores donation history.
     * @path /donations/{donationId}
     * @allow A user can only read their own donation records.
     * @deny Writes are disabled from the client; they must go through the backend API.
     */
    match /donations/{donationId} {
      // A user can read (get or list) their own donation records.
      // For list operations, the query MUST include `where('userId', '==', request.auth.uid)`.
      // The rule also defensively checks for the existence of the 'userId' field.
      allow read: if isSignedIn() &&
                     'userId' in resource.data &&
                     resource.data.userId == request.auth.uid;
      allow create, update, delete: if false; // Writes must be done by the backend.
    }
  }
}
